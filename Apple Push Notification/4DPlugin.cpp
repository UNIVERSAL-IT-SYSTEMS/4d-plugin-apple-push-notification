/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.c
 #	source generated by 4D Plugin Wizard
 #	Project : Apple Push Notification
 #	author : miyako
 #	2013/12/03
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin.h"

namespace APN
{
    CUTF8String CERTIFICATE_PATH;
    CUTF8String PRIVATEKEY_PATH;
	CUTF8String	PEM_PATH;
    CUTF8String SANDBOX_URL = APS_DEFAULT_SANDBOX_URL;
    CUTF8String PRODUCTION_URL = APS_DEFAULT_PRODUCTION_URL;
    unsigned int PRODUCTION_PORT = APS_DEFAULT_PRODUCTION_PORT;
    unsigned int SANDBOX_PORT = APS_DEFAULT_SANDBOX_PORT;	
	
	int Call(char *request, int len, char *host, int port)
	{
		int bytes = 0;
		
		if((request)&&(host))
		{
			SSL *ssl;
			SSL_CTX *ctx;	
			
			struct sockaddr_in server;
			struct hostent *servhost = gethostbyname(host);
			
			if(servhost)
			{
				bzero((char *)&server, sizeof(server));
				
				server.sin_family = AF_INET;
				server.sin_port = htons(port);	
				bcopy(servhost->h_addr, (char *)&server.sin_addr, servhost->h_length);
				
				int s = socket(AF_INET, SOCK_STREAM, 0);
				
				if(s!=-1)// -1 is returned if an error occur
				{
					int c = connect(s, (struct sockaddr *) &server, sizeof(server));
					
					if(c!=-1)//-1 is connection error
					{
						SSL_library_init();
						
						ctx = SSL_CTX_new(SSLv23_client_method());		//SSLv3 but can rollback to v2
						if (ctx)
						{
							SSL_CTX_use_certificate_file(ctx, (const char *)APN::PEM_PATH.c_str(), SSL_FILETYPE_PEM);
							SSL_CTX_use_PrivateKey_file(ctx, (const char *)APN::PEM_PATH.c_str(), SSL_FILETYPE_PEM);						
							ssl = SSL_new(ctx);
							if (ssl)
							{
								if(SSL_set_fd(ssl, s))
								{
									int c = SSL_connect(ssl);
									
									if(c>0)//The TLS/SSL handshake was successfully completed, a TLS/SSL connection has been established.
									{
										
										
										int w = SSL_write(ssl, request, len);	
										if(w>0)//The write operation was successful, the return value is the number of bytes actually written to the TLS/SSL connection.
										{
											bytes = w;
										}
										SSL_shutdown(ssl);						
									}
								}
								SSL_free(ssl);	
							}
							SSL_CTX_free(ctx); 
						}
					}
					close(s);
				}		
			}
		}
		
		return bytes;
	}
	
};

#pragma mark -

void PluginMain(int32_t selector, PA_PluginParameters params)
{
	try
	{
		int32_t pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (int32_t pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{			
// --- Apple Push Notification

		case 1 :
			APN_Get_sandbox_url(pResult, pParams);
			break;

		case 2 :
			APN_SET_PRODUCTION_URL(pResult, pParams);
			break;

		case 3 :
			APN_Get_production_url(pResult, pParams);
			break;

		case 4 :
			APN_Get_pem_path(pResult, pParams);
			break;

		case 5 :
			APN_SET_PEM_PATH(pResult, pParams);
			break;

		case 6 :
			APN_Push_Payload(pResult, pParams);
			break;

		case 7 :
			APN_SET_SANDBOX_PORT(pResult, pParams);
			break;

		case 8 :
			APN_SET_SANDBOX_URL(pResult, pParams);
			break;

		case 9 :
			APN_Get_sandbox_port(pResult, pParams);
			break;

		case 10 :
			APN_SET_PRODUCTION_PORT(pResult, pParams);
			break;

		case 11 :
			APN_Get_production_port(pResult, pParams);
			break;

	}
}

#pragma mark -

// ---------------------------- Apple Push Notification ---------------------------

void APN_Push_Payload(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_TEXT Param2;
	C_LONGINT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

	
	
	if(Param1.getBytesLength()){
	
		char payloadBuff[MAXPAYLOAD_SIZE];
		bzero((char *)payloadBuff, MAXPAYLOAD_SIZE);
		
		int payloadLength = PA_ConvertCharsetToCharset((char *)Param2.getUTF16StringPtr(),
													   Param2.getUTF16Length() * sizeof(PA_Unichar),
													   eVTC_UTF_16,
													   payloadBuff,
													   MAXPAYLOAD_SIZE,
													   eVTC_UTF_8);
		
		char binaryMessageBuff[sizeof(uint8_t)+sizeof(uint16_t)+DEVICE_BINARY_SIZE+sizeof(uint16_t)+MAXPAYLOAD_SIZE];
		char *binaryMessagePt = binaryMessageBuff;
		
		uint16_t networkOrderTokenLength = htons(DEVICE_BINARY_SIZE);
		uint16_t networkOrderPayloadLength = htons(payloadLength); 
		
		/* command number */
		uint8_t command = 0;	
		*binaryMessagePt++ = command;
		
		/* token length network order */		 	 
		memcpy(binaryMessagePt, &networkOrderTokenLength, sizeof(uint16_t));
		
		binaryMessagePt += sizeof(uint16_t);
		
		/* device token */
		memcpy(binaryMessagePt, Param1.getBytesPtr(), DEVICE_BINARY_SIZE);
		binaryMessagePt += DEVICE_BINARY_SIZE;
		
		/* payload length network order */
		memcpy(binaryMessagePt, &networkOrderPayloadLength, sizeof(uint16_t));
		binaryMessagePt += sizeof(uint16_t);
		
		/* payload */	
		memcpy(binaryMessagePt, payloadBuff, payloadLength);
		binaryMessagePt += payloadLength;
		
		int bytes;
		
		switch (Param3.getIntValue())
		{
			case APS_PROVISION_SANDBOX:
				bytes = APN::Call(binaryMessageBuff, (binaryMessagePt - binaryMessageBuff), (char *)APN::SANDBOX_URL.c_str(), APN::SANDBOX_PORT);
				break;
			default:
				bytes = APN::Call(binaryMessageBuff, (binaryMessagePt - binaryMessageBuff), (char *)APN::PRODUCTION_URL.c_str(), APN::PRODUCTION_PORT);		
				break;
		}
		
		returnValue.setIntValue(bytes);
		
	}

	returnValue.setReturn(pResult);
}

void APN_SET_PRODUCTION_URL(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param1.copyUTF8String(&APN::PRODUCTION_URL);
}

void APN_Get_production_url(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	returnValue.setUTF8String(&APN::PRODUCTION_URL);
	returnValue.setReturn(pResult);
}

void APN_SET_PEM_PATH(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param1.copyUTF8String(&APN::PEM_PATH);
}

void APN_Get_pem_path(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	returnValue.setUTF8String(&APN::PEM_PATH);
	returnValue.setReturn(pResult);
}

void APN_SET_SANDBOX_URL(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param1.copyUTF8String(&APN::SANDBOX_URL);
}

void APN_Get_sandbox_url(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	returnValue.setUTF8String(&APN::SANDBOX_URL);
	returnValue.setReturn(pResult);
}

void APN_SET_SANDBOX_PORT(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;

	Param1.fromParamAtIndex(pParams, 1);
	APN::SANDBOX_PORT = Param1.getIntValue();
}

void APN_Get_sandbox_port(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT returnValue;

	returnValue.setIntValue(APN::SANDBOX_PORT);
	returnValue.setReturn(pResult);
}

void APN_SET_PRODUCTION_PORT(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;

	Param1.fromParamAtIndex(pParams, 1);
	APN::PRODUCTION_PORT = Param1.getIntValue();
}

void APN_Get_production_port(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT returnValue;

	returnValue.setIntValue(APN::PRODUCTION_PORT);
	returnValue.setReturn(pResult);
}

